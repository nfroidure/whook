[//]: # ( )
[//]: # (This file is automatically generated by a `metapak`)
[//]: # (module. Do not change it  except between the)
[//]: # (`content:start/end` flags, your changes would)
[//]: # (be overridden.)
[//]: # ( )
# @whook/example
> A basic Whook server

[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/nfroidure/whook/blob/main/packages/whook-example/LICENSE)


[//]: # (::contents:start)

This is a basic [Whook](https://github.com/nfroidure/whook) server demonstrating
the various usages of the Whook framework to build REST APIs.

## Usage

To run the server in production:

```sh
npm it
NODE_ENV=production APP_ENV=production npm start
```

You can understand deeply this repository and Whook's internal by simply reading
the [Architecture Notes](./ARCHITECTURE.md). The "See in context" links drive
your directly in the concerned implementation so that you can just see the code
that explains the notes.

Feel free to continue creating architecture notes and to regenerate the markdown
file by running:

```
npm run architecture
```

## Dev

Start the server in development:

```sh
# Simple dev mode
npm run dev

# Watch mode
npm run watch
```

Create a new route / cron / service / provider or command:

```sh
npx whook create
```

Play with the REPL:

```sh
npm run repl
```

Generate the dependency injection graph (here, for the `putTime` handler):

```sh
npm run --silent whook -- __inject putTime,mermaid > DEPENDENCIES.mmd;
docker run --rm -u `id -u`:`id -g` -v $(pwd):/data minlag/mermaid-cli -i DEPENDENCIES.mmd -o DEPENDENCIES.mmd.svg;
```

List available commands:

```sh
## In dev mode
npm run dev -- ls
## With built files
npx whook ls
```

Generate API types:

```sh
npm run apitypes
```

## Deploying with AWS Lambda

### Pushing to S3

First of all, push the lambdas to S3. If you prefer to use it with your own
architecture later, you can stop at that step:

```sh
NODE_ENV=production APP_ENV=staging npm run build
APP_ENV=staging bin/lambdas_zip.sh
APP_ENV=staging bin/lambdas_push.sh
```

### Deploy with Terraform

Otherwise, here is a full step by step setup for you.

First install Terraform:

```sh
wget https://releases.hashicorp.com/terraform/1.6.2/terraform_1.6.2_linux_amd64.zip
mkdir .bin
unzip -d .bin terraform_1.6.2_linux_amd64.zip
rm terraform_1.6.2_linux_amd64.zip
```

Then initialize the Terraform configuration:

```sh
cd ./terraform
../.bin/terraform init;
```

Create a new workspace for each `APP_ENV`:

```sh
../.bin/terraform workspace new staging
```

Build the lambdas layer:

```sh
NODE_ENV=production bin/lambda_layer.sh
```

Plan the deployment:

```sh
../.bin/terraform plan -out=terraform.plan -var "node_env=${NODE_ENV}"
```

Apply changes:

```sh
../.bin/terraform apply -var "node_env=${NODE_ENV}" terraform.plan
```

Finally retrieve the API URL and add and enjoy!

```sh
../.bin/terraform output api_url
curl "$(.bin/terraform output api_url)staging/v3/ping"
# {"pong":"pong"}
```

## Debug

Execute a handler in isolation:

```sh
npx whook handler --name putEcho --parameters '{"body": { "echo": "YOLO!" }}'
```

Debug `whook` internals:

```sh
DEBUG=whook npm run dev
```

Debug `knifecycle` internals (dependency injection issues):

```sh
DEBUG=knifecycle npm run dev
```

Debug built lambdas:

```sh
## HTTP
APP_ENV=staging npx whook testHTTPLambda --name putEcho \
 --parameters '{ "body": { "echo": "Hey!" } }'
## Cron
APP_ENV=staging npx whook testCronLambda --name handleMinutes
## Consumer
APP_ENV=staging npx whook testConsumerLambda --name handleMessages \
 --event '{ "Records": [{ "test": "test" }] }'
```

[//]: # (::contents:end)

# Authors
- [Nicolas Froidure](http://insertafter.com/en/index.html)

# License
[MIT](https://github.com/nfroidure/whook/blob/main/packages/whook-example/LICENSE)
